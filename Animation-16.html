<!DOCTYPE HTML>
<html>
<head>
</head>
<body style="margin:0px">
  <!--<canvas id="canvas" style="display:block"></canvas> -->  
    <script type="text/javascript">
 
var GIF_image = new Image();

//GIF_image.id = "gifImage_Saturn"
//GIF_image.src = "//C:/Users/Varun/Desktop/asaturn.png";
 
onload = function () {

    var canvas_MAIN = document.createElement('canvas');
    var canvas_BG = document.createElement("canvas");
    var Orbit_BG = document.createElement("canvas");
    var planets = [];
    var stars = [];
    var background_data;

    function generate_Layer1() {
        canvas_MAIN.id = 'canvas';
        canvas_MAIN.id = 'canvas_Top';
        canvas_MAIN.style.display = "block"
        canvas_MAIN.style.zIndex = '1';
        canvas_MAIN.style.position = "absolute"
        canvas_MAIN.style.left = "0px"
        canvas_MAIN.style.top = "0px"
        canvas_MAIN.width = window.innerWidth;
        canvas_MAIN.height = window.innerHeight
        document.body.appendChild(canvas_MAIN);
    }

    generate_Layer1();
    console.clear();

    var div = document.createElement("Div");
        div.id = "div_element_parent"
        div.style.width      = window.innerWidth + 'px';
        div.style.height     = window.innerHeight + 'px';
        div.style.display = "block"
        div.style.zIndex = '1';
        div.style.position = "absolute"
        div.style.left = "0px"
        div.style.top = "0px"
        div.style.backgroundColor =  "rgba(1, 1, 1, 0.3)";
        div.style.color      = "white";
      //  div.innerHTML        = "Hello, This is the new Parent container element";
        document.body.appendChild(div); 

    // Get the canvas element from the DOM
    const canvas = document.getElementById('canvas_Top');
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    // Store the 2D context
    const ctx = canvas.getContext('2d');


    if (window.devicePixelRatio > 1) {
        canvas.width = canvas.clientWidth * 2;
        canvas.height = canvas.clientHeight * 2;
        ctx.scale(2, 2);
    }
    /* ====================== */
    /* ====== VARIABLES ===== */
    /* ====================== */
    let width = canvas.clientWidth; // Width of the canvas
    let height = canvas.clientHeight; // Height of the canvas
    let rotation = 0; // Rotation of the globe
    let dots = []; // Every dots in an array
    
    let Div_Array = []; 
            
    function get_Radius(){

        let GLOBE_RADIUS = 0
        let aspect_ratio = (window.innerWidth)/(window.innerHeight);     

        if(aspect_ratio > 1){
            GLOBE_RADIUS = window.innerHeight * 0.8;
        }
        else{
            GLOBE_RADIUS = window.innerWidth * 0.8;
        }

        return GLOBE_RADIUS;
    }
 
    const DOTS_AMOUNT         = 105; // Amount of dots on the screen
    const DOT_RADIUS          =  10; // Radius of the dots
    let GLOBE_RADIUS          = get_Radius() // Radius of the globe
    let GLOBE_CENTER_Z        = -get_Radius(); // Z value of the globe center
    let PROJECTION_CENTER_X_A = (width / 2) ; // X center o the canvas HTML
    let PROJECTION_CENTER_Y_A = (height / 2); // Y center of the canvas HTML
    let FIELD_OF_VIEW         = GLOBE_RADIUS * 0.8;

    //    let PROJECTION_CENTER_X_B = width - (width / 2) * 1.5;
          
        class Dot {
            constructor(x, y, z, data, theta, phi) {

                this.GLOBE_RADIUS = GLOBE_RADIUS;
                this.radius = 5;
                this.x = x;
                this.y = y;
                this.z = z;
                this.data = data;
                this.static = false;
                this.leaveArea = false;
                this.theta = theta;
                this.phi = phi;

                this.xProject = 0;
                this.yProject = 0;
                this.sizeProjection = 0;
                this.PROJECTION_CENTER_X_A = PROJECTION_CENTER_X_A;
                this.PROJECTION_CENTER_Y_A = PROJECTION_CENTER_Y_A;
            }
        // Do some math to project the 3D position into the 2D canvas
        project(sin, cos) {

            if (this.leaveArea) {
            //    this.preparingToLeave();
            }

            const rotX = cos * this.x + sin * (this.z - GLOBE_CENTER_Z);
            const rotZ = -sin * this.x + cos * (this.z - GLOBE_CENTER_Z) + GLOBE_CENTER_Z;
            this.sizeProjection = FIELD_OF_VIEW / (FIELD_OF_VIEW - rotZ);
            this.xProject = (rotX * this.sizeProjection) + this.PROJECTION_CENTER_X_A;
            this.yProject = (this.y * this.sizeProjection) + PROJECTION_CENTER_Y_A;
        }
        // Draw the dot on the canvas
        draw(sin, cos) {
            this.project(sin, cos);
            // ctx.fillRect(this.xProject - DOT_RADIUS, this.yProject - DOT_RADIUS, DOT_RADIUS * 2 * this.sizeProjection, DOT_RADIUS * 2 * this.sizeProjection);
            ctx.beginPath();
            ctx.arc(this.xProject, this.yProject, DOT_RADIUS * this.sizeProjection, 0, Math.PI * 2);
            //ctx.fill()
            let w   = 12 * this.data.length //+ 20
            let h   = 15 * 1.34;

            ctx.font = '15pt Courier';
            ctx.fillStyle = '#000000';
            ctx.strokeStyle = '#C0C0C0';

            //ctx.fillText(this.data, (this.xProject + this.sizeProjection * DOT_RADIUS), (this.yProject + this.sizeProjection * DOT_RADIUS));
            //ctx.rect((this.xProject + this.sizeProjection * DOT_RADIUS), (this.yProject - 15), (w), (h))

            //ctx.rect((this.xProject + this.sizeProjection * DOT_RADIUS), (this.yProject + this.sizeProjection * DOT_RADIUS), (w), (-h))
            //ctx.closePath();
            //ctx.stroke();
        }

        preparingToLeave() {
            this.GLOBE_RADIUS = GLOBE_RADIUS *1.5
            //this.x =  (this.GLOBE_RADIUS  + 1) * Math.sin(this.phi) * Math.cos(this.theta);
            //this.y =  (this.GLOBE_RADIUS  + 1) * Math.sin(this.phi) * Math.sin(this.theta);
            //this.z = ((this.GLOBE_RADIUS  + 1) * Math.cos(this.phi)) + GLOBE_CENTER_Z;
        }

    }


    function createDots() {
        // Empty the array of dots
        //dots.length = 0;

        // Create a new dot based on the amount needed
        for (let i = 0; i < DOTS_AMOUNT; i++) {
            const theta = Math.random() * 2 * Math.PI; // Random value between [0, 2PI]
            const phi = Math.acos((Math.random() * 2) - 1); // Random value between [-1, 1]

            // Calculate the [x, y, z] coordinates of the dot along the globe
            const x = GLOBE_RADIUS * Math.sin(phi) * Math.cos(theta);
            const y = GLOBE_RADIUS * Math.sin(phi) * Math.sin(theta);
            const z = (GLOBE_RADIUS * Math.cos(phi)) + GLOBE_CENTER_Z;

            let  a = Math.round(1000*Math.random()) 
            let  b = Math.round(1000*Math.random()) 

            let div = document.createElement("Div");
            div.id = "CHILDIV" + x;
            div.className = "ChildDotElement"
            div.style.width = DOT_RADIUS + "px";
            div.style.height = DOT_RADIUS + "px";
            div.style.position = 'absolute'
            div.style.borderRadius = "100%";
            div.style.top  =  a + "px"
            div.style.left =  b + "px" 
            div.style.backgroundColor =  "rgba(50, 50, 50, 0.93)";
            div.style.color = "#222222";
            //div.innerHTML = "Hello, element";
            div.setAttribute("xPositon", a);
            div.setAttribute("yPositon", b);


            div.addEventListener('click', function (event) {  div.innerHTML = "Hello, element"; });
            document.getElementById("div_element_parent").appendChild(div)
            

            dots.push(new Dot(x, y, z, "Test", theta, phi));
        }
    
     
    }

    /* ====================== */
    /* ======== RENDER ====== */
    /* ====================== */
        var total_Width = window.innerWidth;
        var total_Height = window.innerHeight;

    function render( ) {
        // Clear the scene
        ctx.clearRect(0, 0, width, height);

    
        var resolution_x = total_Width/10;
        var resolution_y = total_Height/10;

        ctx.strokeStyle = "#B0B0B0"
        for (var i = 0; i < 20; i++) {
            ctx.beginPath()
            ctx.moveTo(i * resolution_x, 0)
            ctx.lineTo((i + 1) * resolution_y, total_Height)
            ctx.stroke()
        }
        for (var i = 0; i < 20; i++) {
            ctx.beginPath()
            ctx.moveTo(0, i * resolution_y)
            ctx.lineTo(total_Width, (i + 1) * resolution_y)
            ctx.stroke()
        }
         /*   
        ctx.strokeStyle = "#000000"
        
        ctx.beginPath()
        ctx.moveTo(0, 0);
        ctx.lineTo(resolution_x /2 , resolution_y * 9)
        ctx.lineTo(resolution_x * 4.5, resolution_y * 10)
        ctx.lineTo(resolution_x * 5.5, resolution_y * 0.5)
        ctx.lineTo(0, 0)
        ctx.stroke()

        ctx.strokeStyle = "#000000"
        ctx.beginPath()
        ctx.arc(PROJECTION_CENTER_X_B, PROJECTION_CENTER_Y_A, GLOBE_RADIUS , 0, 2 * Math.PI)
        ctx.stroke();
        */
        ctx.beginPath()
        ctx.arc(PROJECTION_CENTER_X_A, PROJECTION_CENTER_Y_A, GLOBE_RADIUS * 0.54 , 0, 2 * Math.PI)
        ctx.stroke();
        
    

        // Increase the globe rotation
        //rotation = a * 0.0004;
        rotation =  rotation+0.0004;

        const sineRotation = Math.sin(rotation); // Sine of the rotation
        const cosineRotation = Math.cos(rotation); // Cosine of the rotation

        var id = null;

        let P = document.getElementById("div_element_parent").childNodes

        // Loop tPROJECTION_CENTER_Y_Ahrough the dots array and draw every dot
        for (var i = 0; i < dots.length; i++) { 

            dots[i].draw(sineRotation, cosineRotation);  
            let this_DOT_RADIUS = Math.round(dots[i].sizeProjection * DOT_RADIUS)
            P[i].style.left  =  dots[i].xProject + "px" 
            P[i].style.top   =  dots[i].yProject+ "px" 
           // P[i].innerHTML   = dots[i].data + this_DOT_RADIUS
            P[i].style.width = this_DOT_RADIUS + "px"
            P[i].style.height = this_DOT_RADIUS + "px"
            //P[i].style.borderRadius = this_DOT_RADIUS + "%" 
        } 
        window.requestAnimationFrame(render);
    }

    // Function called after the user resized its screen
    function afterResize() {
        width = canvas.offsetWidth;
        height = canvas.offsetHeight;
        if (window.devicePixelRatio > 1) {
            canvas.width = canvas.clientWidth * 2;
            canvas.height = canvas.clientHeight * 2;
            ctx.scale(2, 2);
        } else {
            canvas.width = width;
            canvas.height = height;
        }
        GLOBE_RADIUS = width * 0.7;
        GLOBE_CENTER_Z = -GLOBE_RADIUS;
        PROJECTION_CENTER_X_A = width / 2;
        PROJECTION_CENTER_Y_A = height / 2;
        FIELD_OF_VIEW = width * 0.8;

        createDots(); // Reset all dots
    }

    // Variable used to store a timeout when user resized its screen
    let resizeTimeout;
    // Function called right after user resized its screen
    function onResize() {
        // Clear the timeout variable
        resizeTimeout = window.clearTimeout(resizeTimeout);
        // Store a new timeout to avoid calling afterResize for every resize event
        resizeTimeout = window.setTimeout(afterResize, 500);
    }



    window.addEventListener('resize', onResize);

    // Populate the dots array with random dots
    createDots();

    // Render the scene
    window.requestAnimationFrame(render);

}


       // Restart_canvas()
    </script>

</body> 
</html>